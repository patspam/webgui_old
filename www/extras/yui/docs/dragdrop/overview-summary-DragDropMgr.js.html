
<html>
<head>
	<title>JavaScript Documentation - DragDropMgr.js</title>
	<link href="stylesheet.css" rel="stylesheet" type="text/css" />
</head>

<body>

<div id="header">
	<h1>JavaScript Documentation</h1>
	<h3><a href="./index.html">Drag and Drop</a></h3>

	<div class="breadcrumbs">
		
			
			
			
				<a href="./index.html">Drag and Drop</a>
				&gt;
				<strong>DragDropMgr.js</strong>
			
			
			
			
			
			
			
			
			
			
			
		
	</div>
</div>


<div id="body">
	
	
	<div class="nav">
		<div class="module resources">
			<ul class="content">
				<li><a href="overview-tree.html">Tree View</a></li>
				<li><a href="index-all.html">Element Index</a></li>
			</ul>
		</div>
		
		
			<div class="module">
				<h4><a href="./allclasses-noframe.html">Classes</a></h4>
				<ul class="content">
					
						<li>
							<a href="YAHOO.util.html">
								YAHOO.util</a>
						</li>
					
						<li>
							<a href="YAHOO.util.DD.html">
								YAHOO.util.DD</a>
						</li>
					
						<li>
							<a href="YAHOO.util.DDProxy.html">
								YAHOO.util.DDProxy</a>
						</li>
					
						<li>
							<a href="YAHOO.util.DDTarget.html">
								YAHOO.util.DDTarget</a>
						</li>
					
						<li>
							<a href="YAHOO.util.DragDrop.html">
								YAHOO.util.DragDrop</a>
						</li>
					
						<li>
							<a href="YAHOO.util.DragDropMgr.html">
								YAHOO.util.DragDropMgr</a>
						</li>
					
				</ul>
			</div>
		
		
		
			<div class="module">
				<h4><a href="./overview-summary.html">Files</a></h4>
				<ul class="content">		
					
						<li>
							<a href="overview-summary-DD.js.html">
								DD.js</a>
						</li>
					
						<li>
							<a href="overview-summary-DDProxy.js.html">
								DDProxy.js</a>
						</li>
					
						<li>
							<a href="overview-summary-DDTarget.js.html">
								DDTarget.js</a>
						</li>
					
						<li>
							<a href="overview-summary-DragDrop.js.html">
								DragDrop.js</a>
						</li>
					
						<li>
							<a href="overview-summary-DragDropMgr.js.html">
								DragDropMgr.js</a>
						</li>
					
				</ul>
			</div>
		
	</div>
	
	<div class="main">
			
		
		
			
			   <h2>DragDropMgr.js</h2>
			
			
				
					
				
				
				
<div class="meta">
	
	
	
	
	
	
	
	
	
	
		
	
	
	
	
	
	
</div>

			
		
		
		
		
			<div class="quick-links">
				<strong>Quick Links:</strong>&nbsp;
				
					
						<a href="#classSummary">Class Summary</a> |
					
					
				
				
				
					<a href="#source">Source Code</a>
				
			</div>
		
			
				<div class="section class summaries">
					 <h3><a name="classSummary">Class Summary</a> <span class="top">[<a href="#top">top</a>]</span></h3>
			
				<div class="content">
					<table border="1" cellpadding="3" cellspacing="0">
						
						<tr>
							<td class="name">
								<a href="YAHOO.util.DragDropMgr.html">YAHOO.util.DragDropMgr</a>
							</td>
							<td class="overview">&nbsp;</td>
						</tr>
						
					</table>
				</div>
			</div>
		
		
		
		
		
		
		
			<div class="section source">
				<h3><a name="source">Souce Code</a> <span class="top">[<a href="#top">top</a>]</span></h3>
				<pre class="sourceview">
    <span class="comment">/**
     * Handles the element interaction for all DragDrop items in the 
     * window.  Generally, you will not call this class directly, but it does
     * have helper methods that could be useful in your DragDrop 
     * implementations.  This class should not be instantiated; all methods 
     * are are static.
     *
     * <span class="attrib">@constructor</span>
     */</span>
    YAHOO.util.DragDropMgr = <span class="reserved">function</span>() {
        <span class="comment">/**
         * Flag to determine if we should prevent the default behavior of the
         * events we define. By default this is true, but this can be set to 
         * false if you need the default behavior (not recommended)
         *
         * <span class="attrib">@type</span> boolean
         */</span>
        <span class="reserved">this</span>.preventDefault = true;

        <span class="comment">/**
         * Flag to determine if we should stop the propagation of the events 
         * we generate. This is true by default but you may want to set it to
         * false if the html element contains other features that require the
         * mouse click.
         *
         * <span class="attrib">@type</span> boolean
         */</span>
        <span class="reserved">this</span>.stopPropagation = true;

        <span class="comment">/**
         * In point mode, drag and drop interaction is defined by the 
         * location of the cursor during the drag/drop
         * <span class="attrib">@type</span> int
         */</span>
        <span class="reserved">this</span>.POINT     = 0;

        <span class="comment">/**
         * In intersect mode, drag and drop interactio nis defined by the 
         * overlap of two or more drag and drop objects.
         * <span class="attrib">@type</span> int
         */</span>
        <span class="reserved">this</span>.INTERSECT = 1;

        <span class="comment">/**
         * The current drag and drop mode.  Default it point mode
         * <span class="attrib">@type</span> int
         */</span>
        <span class="reserved">this</span>.mode = <span class="reserved">this</span>.POINT;

        <span class="comment">/**
         * Lock all drag and drop functionality
         */</span>
        <span class="reserved">this</span>.lock = <span class="reserved">function</span>() { <span class="reserved">this</span>.locked = true; };

        <span class="comment">/**
         * Unlock all drag and drop functionality
         */</span>
        <span class="reserved">this</span>.unlock = <span class="reserved">function</span>() { <span class="reserved">this</span>.locked = false; };

        <span class="comment">/**
         * Is drag and drop locked?
         *
         * <span class="attrib">@return</span> {boolean} True if drag and drop is locked, false otherwise.
         */</span>
        <span class="reserved">this</span>.isLocked = <span class="reserved">function</span>() { <span class="reserved">return</span> <span class="reserved">this</span>.locked; };
        <span class="comment">/**
         * Set useCache to false if you want to force object the lookup of each
         * drag and drop linked element constantly during a drag.
         * <span class="attrib">@type</span> boolean
         */</span>
        <span class="reserved">this</span>.useCache = true;

        <span class="comment">/**
         * The number of pixels that the mouse needs to move after the 
         * mousedown before the drag is initiated.  Default=3;
         * <span class="attrib">@type</span> int
         */</span>
        <span class="reserved">this</span>.clickPixelThresh = 3;

        <span class="comment">/**
         * The number of milliseconds after the mousedown event to initiate the
         * drag if we don't get a mouseup event. Default=1000
         * <span class="attrib">@type</span> int
         */</span>
        <span class="reserved">this</span>.clickTimeThresh = 1000;
        <span class="comment">/**
         * Each DragDrop instance must be registered with the DragDropMgr.  
         * This is executed in DragDrop.init()
         *
         * <span class="attrib">@param</span> {DragDrop} oDD the DragDrop object to register
         * <span class="attrib">@param</span> {String} sGroup the name of the group this element belongs to
         */</span>
        <span class="reserved">this</span>.regDragDrop = <span class="reserved">function</span>(oDD, sGroup) {
            <span class="reserved">if</span> (!<span class="reserved">this</span>.initialized) { <span class="reserved">this</span>.init(); }
            
            <span class="reserved">if</span> (!<span class="reserved">this</span>.ids[sGroup]) {
                <span class="reserved">this</span>.ids[sGroup] = {};
            }
            <span class="reserved">this</span>.ids[sGroup][oDD.id] = oDD;
        };

        <span class="comment">/**
         * Each DragDrop handle element must be registered.  This is done
         * automatically when executing DragDrop.setHandleElId()
         *
         * <span class="attrib">@param</span> {String} sDDId the DragDrop id this element is a handle for
         * <span class="attrib">@param</span> {String} sHandleId the id of the element that is the drag 
         * handle
         */</span>
        <span class="reserved">this</span>.regHandle = <span class="reserved">function</span>(sDDId, sHandleId) {
            <span class="reserved">if</span> (!<span class="reserved">this</span>.handleIds[sDDId]) {
                <span class="reserved">this</span>.handleIds[sDDId] = {};
            }
            <span class="reserved">this</span>.handleIds[sDDId][sHandleId] = sHandleId;
        };

        <span class="comment">/**
         * Utility function to determine if a given element has been 
         * registered as a drag drop item.
         *
         * <span class="attrib">@param</span> {String} id the element id to check
         * <span class="attrib">@return</span> {boolean} true if this element is a DragDrop item, 
         * false otherwise
         */</span>
        <span class="reserved">this</span>.isDragDrop = <span class="reserved">function</span>(id) {
            <span class="reserved">return</span> ( <span class="reserved">this</span>.getDDById(id) ) ? true : false;
        };

        <span class="comment">/**
         * Returns the drag and drop instances that are in all groups the
         * passed in instance belongs to.
         *
         * <span class="attrib">@param</span> {DragDrop} p_oDD the obj to get related data for
         * <span class="attrib">@param</span> {boolean} bTargetsOnly if true, only return targetable objs
         * <span class="attrib">@return</span> {DragDrop[]} the related instances
         */</span>
        <span class="reserved">this</span>.getRelated = <span class="reserved">function</span>(p_oDD, bTargetsOnly) {
            var oDDs = [];
            <span class="reserved">for</span> (var i in p_oDD.groups) {
                <span class="reserved">for</span> (j in <span class="reserved">this</span>.ids[i]) {
                    var dd = <span class="reserved">this</span>.ids[i][j];
                    <span class="reserved">if</span> (! <span class="reserved">this</span>.isTypeOfDD(dd)) {
                        continue;
                    }
                    <span class="reserved">if</span> (!bTargetsOnly || dd.isTarget) {
                        oDDs[oDDs.length] = dd;
                    }
                }
            }

            <span class="reserved">return</span> oDDs;
        };

        <span class="comment">/**
         * Returns true if the specified dd target is a legal target for 
         * the specifice drag obj
         *
         * <span class="attrib">@param</span> {DragDrop} the drag obj
         * <span class="attrib">@param</span> {DragDrop) the target
         * <span class="attrib">@return</span> {boolean} true if the target is a legal target for the 
         * dd obj
         */</span>
        <span class="reserved">this</span>.isLegalTarget = <span class="reserved">function</span> (oDD, oTargetDD) {
            var targets = <span class="reserved">this</span>.getRelated(oDD, true);
            <span class="reserved">for</span> (var i=0, len=targets.length;i&lt;len;++i) {
                <span class="reserved">if</span> (targets[i].id == oTargetDD.id) {
                    <span class="reserved">return</span> true;
                }
            }

            <span class="reserved">return</span> false;
        };

        <span class="comment">/**
         * My goal is to be able to transparently determine if an object is
         * typeof DragDrop, and the exact subclass of DragDrop.  typeof 
         * returns "object", oDD.constructor.toString() always returns
         * "DragDrop" and not the name of the subclass.  So for now it just
         * evaluates a well-known variable in DragDrop.
         *
         * <span class="attrib">@param</span> {Object} the object to evaluate
         * <span class="attrib">@return</span> {boolean} true if typeof oDD = DragDrop
         */</span>
        <span class="reserved">this</span>.isTypeOfDD = <span class="reserved">function</span> (oDD) {
            <span class="reserved">return</span> (oDD &amp;&amp; oDD.__ygDragDrop);
        };

        <span class="comment">/**
         * Utility function to determine if a given element has been 
         * registered as a drag drop handle for the given Drag Drop object.
         *
         * <span class="attrib">@param</span> {String} id the element id to check
         * <span class="attrib">@return</span> {boolean} true if this element is a DragDrop handle, false 
         * otherwise
         */</span>
        <span class="reserved">this</span>.isHandle = <span class="reserved">function</span>(sDDId, sHandleId) {
            <span class="reserved">return</span> ( <span class="reserved">this</span>.handleIds[sDDId] &amp;&amp; 
                            <span class="reserved">this</span>.handleIds[sDDId][sHandleId] );
        };

        <span class="comment">/**
         * Returns the DragDrop instance for a given id
         *
         * <span class="attrib">@param</span> {String} id the id of the DragDrop object
         * <span class="attrib">@return</span> {DragDrop} the drag drop object, null if it is not found
         */</span>
        <span class="reserved">this</span>.getDDById = <span class="reserved">function</span>(id) {
            <span class="reserved">for</span> (var i in <span class="reserved">this</span>.ids) {
                <span class="reserved">if</span> (<span class="reserved">this</span>.ids[i][id]) {
                    <span class="reserved">return</span> <span class="reserved">this</span>.ids[i][id];
                }
            }
            <span class="reserved">return</span> null;
        };

        <span class="comment">/**
         * Fired when either the drag pixel threshol or the mousedown hold 
         * time threshold has been met.
         * 
         * <span class="attrib">@param</span> x {int} the X position of the original mousedown
         * <span class="attrib">@param</span> y {int} the Y position of the original mousedown
         */</span>
        <span class="reserved">this</span>.startDrag = <span class="reserved">function</span>(x, y) {
            <span class="reserved">this</span>.logger.log(<span class="literal">"firing drag start events"</span>);
            clearTimeout(<span class="reserved">this</span>.clickTimeout);
            <span class="reserved">if</span> (<span class="reserved">this</span>.dragCurrent) {
                <span class="reserved">this</span>.dragCurrent.b4StartDrag(x, y);
                <span class="reserved">this</span>.dragCurrent.startDrag(x, y);
            }
            <span class="reserved">this</span>.dragThreshMet = true;
        };

        <span class="comment">/**
         * Utility to stop event propagation and event default, if these 
         * features are turned on.
         *
         * <span class="attrib">@param</span> {Event} e the event as returned by this.getEvent()
         */</span>
        <span class="reserved">this</span>.stopEvent = <span class="reserved">function</span>(e) {
            <span class="reserved">if</span> (<span class="reserved">this</span>.stopPropagation) {
                YAHOO.util.Event.stopPropagation(e);
            }

            <span class="reserved">if</span> (<span class="reserved">this</span>.preventDefault) {
                YAHOO.util.Event.preventDefault(e);
            }
        };


        <span class="comment">/**
         * Iterates over all of the DragDrop elements to find ones we are 
         * hovering over or dropping on
         *
         * <span class="attrib">@param</span> {Event} e the event
         * <span class="attrib">@param</span> {boolean} isDrop is this a drop op or a mouseover op?
         * <span class="attrib">@private</span>
         */</span>
        <span class="reserved">this</span>.fireEvents = <span class="reserved">function</span>(e, isDrop) {
            var dc = <span class="reserved">this</span>.dragCurrent;
<span class="comment">
            // If the user did the mouse up outside of the window, we could </span>
<span class="comment">            // get here even though we have ended the drag.</span>
            <span class="reserved">if</span> (!dc || dc.isLocked()) {
                <span class="reserved">return</span>;
            }

            var x = YAHOO.util.Event.getPageX(e);
            var y = YAHOO.util.Event.getPageY(e);
            var pt = new YAHOO.util.Point(x,y);
<span class="comment">
            // cache the previous dragOver array</span>
            var oldOvers = [];

            var outEvts   = [];
            var overEvts  = [];
            var dropEvts  = [];
            var enterEvts = [];
<span class="comment">
            // Check to see if the object(s) we were hovering over is no longer </span>
<span class="comment">            // being hovered over so we can fire the onDragOut event</span>
            <span class="reserved">for</span> (var i in <span class="reserved">this</span>.dragOvers) {

                var ddo = <span class="reserved">this</span>.dragOvers[i];

                <span class="reserved">if</span> (! <span class="reserved">this</span>.isTypeOfDD(ddo)) {
                    continue;
                }

                <span class="reserved">if</span> (! <span class="reserved">this</span>.isOverTarget(pt, ddo, <span class="reserved">this</span>.mode)) {
                    outEvts.push( ddo );
                }

                oldOvers[i] = true;
                delete <span class="reserved">this</span>.dragOvers[i];
            }

            <span class="reserved">for</span> (var sGroup in dc.groups) {
<span class="comment">                // this.logger.log("Processing group " + sGroup);</span>
                
                <span class="reserved">if</span> (<span class="literal">"string"</span> != typeof sGroup) {
                    continue;
                }

                <span class="reserved">for</span> (i in <span class="reserved">this</span>.ids[sGroup]) {
                    var oDD = <span class="reserved">this</span>.ids[sGroup][i];
                    <span class="reserved">if</span> (! <span class="reserved">this</span>.isTypeOfDD(oDD)) {
                        continue;
                    }

                    <span class="reserved">if</span> (oDD.isTarget &amp;&amp; !oDD.isLocked() &amp;&amp; oDD != dc) {
                        <span class="reserved">if</span> (<span class="reserved">this</span>.isOverTarget(pt, oDD, <span class="reserved">this</span>.mode)) {
<span class="comment">                            // look for drop interactions</span>
                            <span class="reserved">if</span> (isDrop) {
                                dropEvts.push( oDD );
<span class="comment">                            // look for drag enter and drag over interactions</span>
                            } <span class="reserved">else</span> {
<span class="comment">
                                // initial drag over: dragEnter fires</span>
                                <span class="reserved">if</span> (!oldOvers[oDD.id]) {
                                    enterEvts.push( oDD );
<span class="comment">                                // subsequent drag overs: dragOver fires</span>
                                } <span class="reserved">else</span> {
                                    overEvts.push( oDD );
                                }

                                <span class="reserved">this</span>.dragOvers[oDD.id] = oDD;
                            }
                        }
                    }
                }
            }

            <span class="reserved">if</span> (<span class="reserved">this</span>.mode) {
                <span class="reserved">if</span> (outEvts.length) {
                    <span class="reserved">this</span>.logger.log(dc.id+<span class="literal">" onDragOut: "</span> + outEvts);
                    dc.b4DragOut(e, outEvts);
                    dc.onDragOut(e, outEvts);
                }

                <span class="reserved">if</span> (enterEvts.length) {
                    <span class="reserved">this</span>.logger.log(dc.id+<span class="literal">" onDragEnter: "</span> + enterEvts);
                    dc.onDragEnter(e, enterEvts);
                }

                <span class="reserved">if</span> (overEvts.length) {
                    <span class="reserved">this</span>.logger.log(dc.id+<span class="literal">" onDragOver: "</span> + overEvts);
                    dc.b4DragOver(e, overEvts);
                    dc.onDragOver(e, overEvts);
                }

                <span class="reserved">if</span> (dropEvts.length) {
                    <span class="reserved">this</span>.logger.log(dc.id+<span class="literal">" onDragDrop: "</span> + dropEvts);
                    dc.b4DragDrop(e, dropEvts);
                    dc.onDragDrop(e, dropEvts);
                }

            } <span class="reserved">else</span> {
<span class="comment">                // fire dragout events</span>
                var len = 0;
                <span class="reserved">for</span> (i=0, len=outEvts.length; i&lt;len; ++i) {
                    <span class="reserved">this</span>.logger.log(dc.id+<span class="literal">" onDragOut: "</span> + outEvts[i].id);
                    dc.b4DragOut(e, outEvts[i].id);
                    dc.onDragOut(e, outEvts[i].id);
                }
<span class="comment">                 
                // fire enter events</span>
                <span class="reserved">for</span> (i=0,len=enterEvts.length; i&lt;len; ++i) {
                    <span class="reserved">this</span>.logger.log(dc.id + <span class="literal">" onDragEnter "</span> + enterEvts[i].id);
<span class="comment">                    // dc.b4DragEnter(e, oDD.id);</span>
                    dc.onDragEnter(e, enterEvts[i].id);
                }
<span class="comment">         
                // fire over events</span>
                <span class="reserved">for</span> (i=0,len=overEvts.length; i&lt;len; ++i) {
                    <span class="reserved">this</span>.logger.log(dc.id + <span class="literal">" onDragOver "</span> + overEvts[i].id);
                    dc.b4DragOver(e, overEvts[i].id);
                    dc.onDragOver(e, overEvts[i].id);
                }
<span class="comment">
                // fire drop events</span>
                <span class="reserved">for</span> (i=0, len=dropEvts.length; i&lt;len; ++i) {
                    <span class="reserved">this</span>.logger.log(dc.id + <span class="literal">" dropped on "</span> + dropEvts[i].id);
                    dc.b4DragDrop(e, dropEvts[i].id);
                    dc.onDragDrop(e, dropEvts[i].id);
                }

            }

        };

        <span class="comment">/**
         * Helper function for getting the best match from the list of drag 
         * and drop objects returned by the drag and drop events when we are 
         * in INTERSECT mode.  It returns either the first object that the 
         * cursor is over, or the object that has the greatest overlap with 
         * the dragged element.
         *
         * <span class="attrib">@param</span>  {DragDrop[]} dds The array of drag and drop objects 
         * targeted
         * <span class="attrib">@return</span> {DragDrop}       The best single match
         */</span>
        <span class="reserved">this</span>.getBestMatch = <span class="reserved">function</span>(dds) {
            var winner = null;
<span class="comment">            // Return null if the input is not what we expect</span>
<span class="comment">            //if (!dds || !dds.length || dds.length == 0) {</span>
<span class="comment">               // winner = null;</span>
<span class="comment">            // If there is only one item, it wins</span>
<span class="comment">            //} else if (dds.length == 1) {</span>

            var len = dds.length;

            <span class="reserved">if</span> (len == 1) {
                winner = dds[0];
            } <span class="reserved">else</span> {
<span class="comment">                // Loop through the targeted items</span>
                <span class="reserved">for</span> (var i=0; i&lt;len; ++i) {
                    var dd = dds[i];
<span class="comment">                    // If the cursor is over the object, it wins.  If the </span>
<span class="comment">                    // cursor is over multiple matches, the first one we come</span>
<span class="comment">                    // to wins.</span>
                    <span class="reserved">if</span> (dd.cursorIsOver) {
                        winner = dd;
                        break;
<span class="comment">                    // Otherwise the object with the most overlap wins</span>
                    } <span class="reserved">else</span> {
                        <span class="reserved">if</span> (!winner || 
                            winner.overlap.getArea() &lt; dd.overlap.getArea()) {
                            winner = dd;
                        }
                    }
                }
            }

            <span class="reserved">return</span> winner;
        };

        <span class="comment">/**
         * Refreshes the cache of the top-left and bottom-right points of the 
         * drag and drop objects in the specified groups
         *
         * <span class="attrib">@param</span> {Object} groups an associative array of groups to refresh
         */</span>
        <span class="reserved">this</span>.refreshCache = <span class="reserved">function</span>(groups) {
            <span class="reserved">this</span>.logger.log(<span class="literal">"refreshing element location cache"</span>);
            <span class="reserved">for</span> (sGroup in groups) {
                <span class="reserved">if</span> (<span class="literal">"string"</span> != typeof sGroup) {
                    continue;
                }
                <span class="reserved">for</span> (i in <span class="reserved">this</span>.ids[sGroup]) {
                    var oDD = <span class="reserved">this</span>.ids[sGroup][i];

                    <span class="reserved">if</span> (<span class="reserved">this</span>.isTypeOfDD(oDD)) {
<span class="comment">                    // if (this.isTypeOfDD(oDD) &amp;&amp; oDD.isTarget) {</span>
                        var loc = <span class="reserved">this</span>.getLocation(oDD);
                        <span class="reserved">if</span> (loc) {
                            <span class="reserved">this</span>.locationCache[oDD.id] = loc;
                        } <span class="reserved">else</span> {
                            delete <span class="reserved">this</span>.locationCache[oDD.id];
                            <span class="reserved">this</span>.logger.log(<span class="literal">"Could not get the loc for "</span> + oDD.id,
                                    <span class="literal">"warn"</span>);
<span class="comment">                            // this will unregister the drag and drop object if</span>
<span class="comment">                            // the element is not in a usable state</span>
<span class="comment">                            // oDD.unreg();</span>
                        }
                    }
                }
            }
        };

        <span class="comment">/**
         * This checks to make sure an element exists and is in the DOM.  The
         * main purpose is to handle cases where innerHTML is used to remove
         * drag and drop objects from the DOM.  IE provides an 'unspecified
         * error' when trying to access the offsetParent of such an element
         * <span class="attrib">@param</span> {HTMLElement} el the element to check
         * <span class="attrib">@return</span> {boolean} true if the element looks usable
         */</span>
        <span class="reserved">this</span>.verifyEl = <span class="reserved">function</span>(el) {
            try {
                <span class="reserved">if</span> (el) {
                    var parent = el.offsetParent;
                    <span class="reserved">if</span> (parent) {
                        <span class="reserved">return</span> true;
                    }
                }
            } catch(e) {
                <span class="reserved">this</span>.logger.log(<span class="literal">"detected problem with an element"</span>);
            }

            <span class="reserved">return</span> false;
        };
        
        <span class="comment">/**
         * Returns the an array containing the drag and drop element's position
         * and size, including the DragDrop.padding configured for it
         *
         * <span class="attrib">@param</span> {DragDrop} oDD the drag and drop object to get the 
         * location for
         * <span class="attrib">@return</span> array containing the top left and bottom right points of the 
         * element 
         */</span>
        <span class="reserved">this</span>.getLocation = <span class="reserved">function</span>(oDD) {
            <span class="reserved">if</span> (! <span class="reserved">this</span>.isTypeOfDD(oDD)) {
                <span class="reserved">this</span>.logger.log(oDD + <span class="literal">" is not a DD obj"</span>);
                <span class="reserved">return</span> null;
            }

            var el = oDD.getEl();
<span class="comment">
            // element will not have an offsetparent if it was removed from the</span>
<span class="comment">            // document or display=none</span>
<span class="comment">            // if (!this.verifyEl(el)) {</span>
<span class="comment">                // this.logger.log(oDD + " element is not usable");</span>
<span class="comment">                // return null;</span>
<span class="comment">            // }</span>
<span class="comment">
            // this.logger.log(oDD.id + " padding: " + oDD.padding);</span>
<span class="comment">
            // var aPos = ygPos.getPos(el);</span>
            var aPos = null;
            try {
                aPos= YAHOO.util.Dom.getXY(el);
            } catch (e) { }

            <span class="reserved">if</span> (!aPos) {
                <span class="reserved">return</span> null;
            }

            x1 = aPos[0];
            x2 = x1 + el.offsetWidth;

            y1 = aPos[1];
            y2 = y1 + el.offsetHeight;

            var t = y1 - oDD.padding[0];
            var r = x2 + oDD.padding[1];
            var b = y2 + oDD.padding[2];
            var l = x1 - oDD.padding[3];

            <span class="reserved">return</span> new YAHOO.util.Region( t, r, b, l );

        };

        <span class="comment">/**
         * Checks the cursor location to see if it over the target
         * 
         * <span class="attrib">@param</span> {YAHOO.util.Point} pt The point to evaluate
         * <span class="attrib">@param</span> {DragDrop} oTarget the DragDrop object we are inspecting
         * <span class="attrib">@return</span> {boolean} true if the mouse is over the target
         * <span class="attrib">@private</span>
         */</span>
        <span class="reserved">this</span>.isOverTarget = <span class="reserved">function</span>(pt, oTarget, intersect) {
<span class="comment">            // use cache if available</span>
            var loc = <span class="reserved">this</span>.locationCache[oTarget.id];
            <span class="reserved">if</span> (!loc || !<span class="reserved">this</span>.useCache) {
                <span class="reserved">this</span>.logger.log(<span class="literal">"cache not populated"</span>);
                loc = <span class="reserved">this</span>.getLocation(oTarget);
                <span class="reserved">this</span>.locationCache[oTarget.id] = loc;

                <span class="reserved">this</span>.logger.log(<span class="literal">"cache: "</span> + loc);
            }

            <span class="reserved">if</span> (!loc) {
                <span class="reserved">return</span> false;
            }

            oTarget.cursorIsOver = loc.contains( pt );
<span class="comment">
            // DragDrop is using this as a sanity check for the initial mousedown</span>
<span class="comment">            // in this case we are done.  In POINT mode, if the drag obj has no</span>
<span class="comment">            // contraints, we are also done. Otherwise we need to evaluate the </span>
<span class="comment">            // location of the target as related to the actual location of the</span>
<span class="comment">            // dragged element.</span>
            var dc = <span class="reserved">this</span>.dragCurrent;
            <span class="reserved">if</span> (!dc || (!intersect &amp;&amp; !dc.constrainX &amp;&amp; !dc.constrainY)) {
                <span class="reserved">return</span> oTarget.cursorIsOver;
            }

            oTarget.overlap = null;
<span class="comment">
            // Get the current location of the drag element, this is the</span>
<span class="comment">            // location of the mouse event less the delta that represents</span>
<span class="comment">            // where the original mousedown happened on the element.  We</span>
<span class="comment">            // need to consider constraints and ticks as well.</span>
            var pos = dc.getTargetCoord(pt.x, pt.y);

            var el = dc.getDragEl();
            var curRegion = new YAHOO.util.Region( pos.y, 
                                                   pos.x + el.offsetWidth,
                                                   pos.y + el.offsetHeight, 
                                                   pos.x );

            var overlap = curRegion.intersect(loc);

            <span class="reserved">if</span> (overlap) {
                oTarget.overlap = overlap;
                <span class="reserved">return</span> (intersect) ? true : oTarget.cursorIsOver;
            } <span class="reserved">else</span> {
                <span class="reserved">return</span> false;
            }
        };

        <span class="comment">/**
         * <span class="attrib">@private</span>
         */</span>
        <span class="reserved">this</span>._onUnload = <span class="reserved">function</span>(e, me) {
            <span class="reserved">this</span>.unregAll();
        };

        <span class="comment">/**
         * Cleans up the drag and drop events and objects.
         * <span class="attrib">@private</span>
         */</span>
        <span class="reserved">this</span>.unregAll = <span class="reserved">function</span>() {
            <span class="reserved">this</span>.logger.log(<span class="literal">"unregister all"</span>);

            <span class="reserved">if</span> (<span class="reserved">this</span>.dragCurrent) {
                <span class="reserved">this</span>.stopDrag();
                <span class="reserved">this</span>.dragCurrent = null;
            }

            <span class="reserved">this</span>._execOnAll(<span class="literal">"unreg"</span>, []);

            <span class="reserved">for</span> (i in <span class="reserved">this</span>.elementCache) {
                delete <span class="reserved">this</span>.elementCache[i];
            }

            <span class="reserved">this</span>.elementCache = {};
            <span class="reserved">this</span>.ids = {};
        };

        <span class="comment">/**
         * A cache of DOM elements
         * <span class="attrib">@private</span>
         */</span>
        <span class="reserved">this</span>.elementCache = {};
        
        <span class="comment">/**
         * Get the wrapper for the DOM element specified
         *
         * <span class="attrib">@param</span> {String} id the id of the elment to get
         * <span class="attrib">@return</span> {YAHOO.util.DDM.ElementWrapper} the wrapped element
         * <span class="attrib">@private</span>
         * <span class="attrib">@deprecated</span>
         */</span>
        <span class="reserved">this</span>.getElWrapper = <span class="reserved">function</span>(id) {
            var oWrapper = <span class="reserved">this</span>.elementCache[id];
            <span class="reserved">if</span> (!oWrapper || !oWrapper.el) {
                oWrapper = <span class="reserved">this</span>.elementCache[id] = 
                    new <span class="reserved">this</span>.ElementWrapper(YAHOO.util.Dom.get(id));
            }
            <span class="reserved">return</span> oWrapper;
        };

        <span class="comment">/**
         * Returns the actual DOM element
         *
         * <span class="attrib">@param</span> {String} id the id of the elment to get
         * <span class="attrib">@return</span> {Object} The element
         * <span class="attrib">@deprecated</span>
         */</span>
        <span class="reserved">this</span>.getElement = <span class="reserved">function</span>(id) {
            <span class="reserved">return</span> YAHOO.util.Dom.get(id);
        };
        
        <span class="comment">/**
         * Returns the style property for the DOM element (i.e., 
         * document.getElById(id).style)
         *
         * <span class="attrib">@param</span> {String} id the id of the elment to get
         * <span class="attrib">@return</span> {Object} The style property of the element
         * <span class="attrib">@deprecated</span>
         */</span>
        <span class="reserved">this</span>.getCss = <span class="reserved">function</span>(id) {
            var el = YAHOO.util.Dom.get(id);
            <span class="reserved">return</span> (el) ? el.style : null;
        };

        <span class="comment">/**
         * Inner class for cached elements
         * <span class="attrib">@private</span>
         * <span class="attrib">@deprecated</span>
         */</span>
        <span class="reserved">this</span>.ElementWrapper = <span class="reserved">function</span>(el) {
                <span class="comment">/**
                 * <span class="attrib">@private</span>
                 */</span>
                <span class="reserved">this</span>.el = el || null;
                <span class="comment">/**
                 * <span class="attrib">@private</span>
                 */</span>
                <span class="reserved">this</span>.id = <span class="reserved">this</span>.el &amp;&amp; el.id;
                <span class="comment">/**
                 * <span class="attrib">@private</span>
                 */</span>
                <span class="reserved">this</span>.css = <span class="reserved">this</span>.el &amp;&amp; el.style;
            };

        <span class="comment">/**
         * Returns the X position of an html element
         * <span class="attrib">@param</span> el the element for which to get the position
         * <span class="attrib">@return</span> {int} the X coordinate
         * <span class="attrib">@deprecated</span>
         */</span>
        <span class="reserved">this</span>.getPosX = <span class="reserved">function</span>(el) {
            <span class="reserved">return</span> YAHOO.util.Dom.getX(el);
        };

        <span class="comment">/**
         * Returns the Y position of an html element
         * <span class="attrib">@param</span> el the element for which to get the position
         * <span class="attrib">@return</span> {int} the Y coordinate
         * <span class="attrib">@deprecated</span>
         */</span>
        <span class="reserved">this</span>.getPosY = <span class="reserved">function</span>(el) {
            <span class="reserved">return</span> YAHOO.util.Dom.getY(el); 
        };

        <span class="comment">/**
         * Swap two nodes.  In IE, we use the native method, for others we 
         * emulate the IE behavior
         *
         * <span class="attrib">@param</span> n1 the first node to swap
         * <span class="attrib">@param</span> n2 the other node to swap
         */</span>
        <span class="reserved">this</span>.swapNode = <span class="reserved">function</span>(n1, n2) {
            <span class="reserved">if</span> (n1.swapNode) {
                n1.swapNode(n2);
            } <span class="reserved">else</span> {
<span class="comment">                // the node reference order for the swap is a little tricky. </span>
                var p = n2.parentNode;
                var s = n2.nextSibling;
                n1.parentNode.replaceChild(n2, n1);
                p.insertBefore(n1,s);
            }
        };

        <span class="comment">/**
         * <span class="attrib">@private</span>
         */</span>
        <span class="reserved">this</span>.getScroll = <span class="reserved">function</span> () {
            var t, l;
            <span class="reserved">if</span> (document.documentElement &amp;&amp; document.documentElement.scrollTop) {
                t = document.documentElement.scrollTop;
                l = document.documentElement.scrollLeft;
            } <span class="reserved">else</span> <span class="reserved">if</span> (document.body) {
                t = document.body.scrollTop;
                l = document.body.scrollLeft;
            }
            <span class="reserved">return</span> { top: t, left: l };
        };

        <span class="comment">/**
         * Returns the specified element style property
         * <span class="attrib">@param</span> {HTMLElement} el          the element
         * <span class="attrib">@param</span> {string}      styleProp   the style property
         * <span class="attrib">@return</span> {string} The value of the style property
         * <span class="attrib">@deprecated</span>, use YAHOO.util.Dom.getStyle
         */</span>
        <span class="reserved">this</span>.getStyle = <span class="reserved">function</span>(el, styleProp) {
            <span class="reserved">return</span> YAHOO.util.Dom.getStyle(el, styleProp);
        };

        <span class="comment">/**
         * Gets the scrollTop
         * <span class="attrib">@return</span> {int} the document's scrollTop
         */</span>
        <span class="reserved">this</span>.getScrollTop = <span class="reserved">function</span> () { <span class="reserved">return</span> <span class="reserved">this</span>.getScroll().top; };

        <span class="comment">/**
         * Gets the scrollLeft
         * <span class="attrib">@return</span> {int} the document's scrollTop
         */</span>
        <span class="reserved">this</span>.getScrollLeft = <span class="reserved">function</span> () { <span class="reserved">return</span> <span class="reserved">this</span>.getScroll().left; };

        <span class="comment">/**
         * Sets the x/y position of an element to the location of the
         * target element.
         * <span class="attrib">@param</span> {HTMLElement} moveEl      The element to move
         * <span class="attrib">@param</span> {HTMLElement} targetEl    The position reference element
         */</span>
        <span class="reserved">this</span>.moveToEl = <span class="reserved">function</span> (moveEl, targetEl) {
            var aCoord = YAHOO.util.Dom.getXY(targetEl);
            <span class="reserved">this</span>.logger.log(<span class="literal">"moveToEl: "</span> + aCoord);
            YAHOO.util.Dom.setXY(moveEl, aCoord);
        };

        <span class="comment">/**
         * Gets the client height
         * <span class="attrib">@return</span> {int} client height in px
         * <span class="attrib">@deprecated</span>
         */</span>
        <span class="reserved">this</span>.getClientHeight = <span class="reserved">function</span>() {
            <span class="reserved">return</span> YAHOO.util.Dom.getClientHeight();
        };

        <span class="comment">/**
         * Gets the client width
         * <span class="attrib">@return</span> {int} client width in px
         * <span class="attrib">@deprecated</span>
         */</span>
        <span class="reserved">this</span>.getClientWidth = <span class="reserved">function</span>() {
            <span class="reserved">return</span> YAHOO.util.Dom.getClientWidth();
        };

        <span class="comment">/**
         * numeric array sort function
         */</span>
        <span class="reserved">this</span>.numericSort = <span class="reserved">function</span>(a, b) { <span class="reserved">return</span> (a - b); };

        <span class="comment">/**
         * <span class="attrib">@private</span>
         */</span>
        <span class="reserved">this</span>._timeoutCount = 0;

        <span class="comment">/**
         * Trying to make the load order less important.  Without this we get
         * an error if this file is loaded before the Event Utility.
         * <span class="attrib">@private</span>
         */</span>
        <span class="reserved">this</span>._addListeners = <span class="reserved">function</span>() {
            <span class="reserved">if</span> ( YAHOO.util.Event &amp;&amp; document ) {
                <span class="reserved">this</span>._onLoad();
            } <span class="reserved">else</span> {
                <span class="reserved">if</span> (<span class="reserved">this</span>._timeoutCount &gt; 1000) {
                    <span class="reserved">this</span>.logger.log(<span class="literal">"DragDrop requires the Event Utility"</span>);
                } <span class="reserved">else</span> {
                    var DDM = YAHOO.util.DDM;
                    setTimeout( <span class="reserved">function</span>() { DDM._addListeners(); }, 10);
                    <span class="reserved">if</span> (document &amp;&amp; document.body) {
                        <span class="reserved">this</span>._timeoutCount += 1;
                    }
                }
            }
        };

        <span class="comment">/**
         * Recursively searches the immediate parent and all child nodes for 
         * the handle element in order to determine wheter or not it was 
         * clicked.
         * <span class="attrib">@param</span> node the html element to inspect
         */</span>
        <span class="reserved">this</span>.handleWasClicked = <span class="reserved">function</span>(node, id) {
            <span class="reserved">if</span> (<span class="reserved">this</span>.isHandle(id, node.id)) {
                <span class="reserved">this</span>.logger.log(<span class="literal">"clicked node is a handle"</span>);
                <span class="reserved">return</span> true;
            } <span class="reserved">else</span> {
<span class="comment">                // check to see if this is a text node child of the one we want</span>
                var p = node.parentNode;
<span class="comment">                // this.logger.log("p: " + p);</span>

                <span class="reserved">while</span> (p) {
                    <span class="reserved">if</span> (<span class="reserved">this</span>.isHandle(id, p.id)) {
                        <span class="reserved">return</span> true;
                    } <span class="reserved">else</span> {
                        <span class="reserved">this</span>.logger.log(p.id + <span class="literal">" is not a handle"</span>);
                        p = p.parentNode;
                    }
                }
            }

            <span class="reserved">return</span> false;
        };

    };


</pre>
			</div>
		
	</div>
</div>


<div id="footer">
    <hr />
    Copyright &copy; 2004 - 2006 Yahoo! Inc. All rights reserved.
</div>


</body>
</html>
