
<html>
<head>
	<title>
		JavaScript Documentation - 
		
			Dom.js
		
	</title>
	<link href="stylesheet.css" rel="stylesheet" type="text/css" />
</head>

<body>

<div id="header">
	<h1>JavaScript Documentation</h1>
	<h3><a href="./index.html">Dom Utility</a></h3>

	<div class="breadcrumbs">
		
			<a href="javascript: alert('This location is TBD');">Home</a>
			&gt;
			
			
			
			
				<a href="./index.html">Dom Utility</a>
				&gt;
				<strong>Dom.js</strong>
			
			
			
			
			
			
			
			
			
			
			
		
	</div>
</div>

<div id="body">
	
	
	<div class="nav">
		<div class="module resources">
			<ul class="content">
				<li><a href="overview-tree.html">Tree View</a></li>
				<li><a href="index-all.html">Element Index</a></li>
			</ul>
		</div>
		
		
			<div class="module">
				<h4><a href="./allclasses-noframe.html">Classes</a></h4>
				<ul class="content">
					
						<li>
							<a href="YAHOO.util.html">
								YAHOO.util</a>
						</li>
					
						<li>
							<a href="YAHOO.util.Point.html">
								YAHOO.util.Point</a>
						</li>
					
						<li>
							<a href="YAHOO.util.Region.html">
								YAHOO.util.Region</a>
						</li>
					
				</ul>
			</div>
		
		
		
			<div class="module">
				<h4><a href="./overview-summary.html">Files</a></h4>
				<ul class="content">		
					
						<li>
							<a href="overview-summary-Dom.js.html">
								Dom.js</a>
						</li>
					
						<li>
							<a href="overview-summary-Region.js.html">
								Region.js</a>
						</li>
					
				</ul>
			</div>
		
	</div>
	
	<div class="main">
			
		
		
			
			   <h2>Dom.js</h2>
			
			
				
					
				
				
				
<div class="meta">
	
	
	
	
	
	
	
	
	
		
	
	
	
	
	
	
</div>

			
		
		
		
		
		
		
		
		
		
			<div class="section source">
				<h3><a name="source">Souce Code</a> <span class="top">[<a href="#top">top</a>]</span></h3>
				<pre class="sourceview"><span class="comment">/*
Copyright (c) 2006, Yahoo! Inc. All rights reserved.
Code licensed under the BSD License:
http://developer.yahoo.net/yui/license.txt
*/</span>

<span class="comment">/**
 * <span class="attrib">@class</span> Provides helper methods for DOM elements.
 */</span>
YAHOO.util.Dom = <span class="reserved">function</span>() {
   var ua = navigator.userAgent.toLowerCase();
   var isOpera = (ua.indexOf(<span class="literal">'opera'</span>) &gt; -1);
   var isSafari = (ua.indexOf(<span class="literal">'safari'</span>) &gt; -1);
   var isIE = (window.ActiveXObject);

   var id_counter = 0;
   var util = YAHOO.util; <span class="comment">// internal shorthand</span>
   var property_cache = {}; <span class="comment">// to cache case conversion for set/getStyle</span>
   var logger = {};
   logger.log = <span class="reserved">function</span>() {YAHOO.log.apply(window, arguments)};
   
   var toCamel = <span class="reserved">function</span>(property) {
      var convert = <span class="reserved">function</span>(prop) {
         var test = /(-[a-z])/i.exec(prop);
         <span class="reserved">return</span> prop.replace(RegExp.$1, RegExp.$1.substr(1).toUpperCase());
      };
      
      <span class="reserved">while</span>(property.indexOf(<span class="literal">'-'</span>) &gt; -1) {
         property = convert(property);
      }

      <span class="reserved">return</span> property;
      <span class="comment">//return property.replace(/-([a-z])/gi, function(m0, m1) {return m1.toUpperCase()}) // cant use function as 2nd arg yet due to safari bug</span>
   };
   
   var toHyphen = <span class="reserved">function</span>(property) {
      <span class="reserved">if</span> (property.indexOf(<span class="literal">'-'</span>) &gt; -1) { <span class="comment">// assume hyphen</span>
         <span class="reserved">return</span> property;
      }
      
      var converted = <span class="literal">''</span>;
      <span class="reserved">for</span> (var i = 0, len = property.length;i &lt; len; ++i) {
         <span class="reserved">if</span> (property.charAt(i) == property.charAt(i).toUpperCase()) {
            converted = converted + <span class="literal">'-'</span> + property.charAt(i).toLowerCase();
         } <span class="reserved">else</span> {
            converted = converted + property.charAt(i);
         }
      }

      <span class="reserved">return</span> converted;
      <span class="comment">//return property.replace(/([a-z])([A-Z]+)/g, function(m0, m1, m2) {return (m1 + '-' + m2.toLowerCase())});</span>
   };
   
   <span class="comment">// improve performance by only looking up once</span>
   var cacheConvertedProperties = <span class="reserved">function</span>(property) {
      property_cache[property] = {
         camel: toCamel(property),
         hyphen: toHyphen(property)
      };
   };
   
   <span class="reserved">return</span> {
      <span class="comment">/**
       * Returns an HTMLElement reference
       * <span class="attrib">@param</span> {String/HTMLElement/Array} el Accepts a string to use as an ID for getting a DOM reference, an actual DOM reference, or an Array of IDs and/or HTMLElements.
       * <span class="attrib">@return</span> {HTMLElement/Array} A DOM reference to an HTML element or an array of HTMLElements.
       */</span>
      get: <span class="reserved">function</span>(el) {
         <span class="reserved">if</span> (typeof el != <span class="literal">'string'</span> &amp;&amp; !(el instanceof Array) ) { <span class="comment">// assuming HTMLElement or HTMLCollection, so pass back as is</span>
            logger.log(<span class="literal">'get('</span> + el + <span class="literal">') returning '</span> + el, <span class="literal">'info'</span>, <span class="literal">'Dom'</span>);
            <span class="reserved">return</span> el;
         }
         
         <span class="reserved">if</span> (typeof el == <span class="literal">'string'</span>) { <span class="comment">// ID</span>
            logger.log(<span class="literal">'get("'</span> + el + <span class="literal">'") returning '</span> + document.getElementById(el), <span class="literal">'info'</span>, <span class="literal">'Dom'</span>);
            <span class="reserved">return</span> document.getElementById(el);
         }
         <span class="reserved">else</span> { <span class="comment">// array of ID's and/or elements</span>
            var collection = [];
            <span class="reserved">for</span> (var i = 0, len = el.length; i &lt; len; ++i) {
               collection[collection.length] = util.Dom.get(el[i]);
            }
            
            logger.log(<span class="literal">'get("'</span> + el + <span class="literal">'") returning '</span> + collection, <span class="literal">'info'</span>, <span class="literal">'Dom'</span>);
            <span class="reserved">return</span> collection;
         }

         logger.log(<span class="literal">'element '</span> + el + <span class="literal">' not found'</span>, <span class="literal">'error'</span>, <span class="literal">'Dom'</span>);
         <span class="reserved">return</span> null; <span class="comment">// safety, should never happen</span>
      },
   
      <span class="comment">/**
       * Normalizes currentStyle and ComputedStyle.
       * <span class="attrib">@param</span> {String/HTMLElement/Array} el Accepts a string to use as an ID, an actual DOM reference, or an Array of IDs and/or HTMLElements.
       * <span class="attrib">@param</span> {String} property The style property whose value is returned.
       * <span class="attrib">@return</span> {String/Array} The current value of the style property for the element(s).
       */</span>
      getStyle: <span class="reserved">function</span>(el, property) {
         var f = <span class="reserved">function</span>(el) {
            var value = null;
            var dv = document.defaultView;
            
            <span class="reserved">if</span> (!property_cache[property]) {
               cacheConvertedProperties(property);
            }
            
            var camel = property_cache[property][<span class="literal">'camel'</span>];
            var hyphen = property_cache[property][<span class="literal">'hyphen'</span>];

            <span class="reserved">if</span> (property == <span class="literal">'opacity'</span> &amp;&amp; el.filters) {<span class="comment">// IE opacity</span>
               value = 1;
               try {
                  value = el.filters.item(<span class="literal">'DXImageTransform.Microsoft.Alpha'</span>).opacity / 100;
               } catch(e) {
                  try {
                     value = el.filters.item(<span class="literal">'alpha'</span>).opacity / 100;
                  } catch(e) {}
               }
            } <span class="reserved">else</span> <span class="reserved">if</span> (el.style[camel]) { <span class="comment">// camelCase for valid styles</span>
               value = el.style[camel];
            }
            <span class="reserved">else</span> <span class="reserved">if</span> (isIE &amp;&amp; el.currentStyle &amp;&amp; el.currentStyle[camel]) { <span class="comment">// camelCase for currentStyle; isIE to workaround broken Opera 9 currentStyle</span>
               value = el.currentStyle[camel];
            }
            <span class="reserved">else</span> <span class="reserved">if</span> ( dv &amp;&amp; dv.getComputedStyle ) { <span class="comment">// hyphen-case for computedStyle</span>
               var computed = dv.getComputedStyle(el, <span class="literal">''</span>);
               
               <span class="reserved">if</span> (computed &amp;&amp; computed.getPropertyValue(hyphen)) {
                  value = computed.getPropertyValue(hyphen);
               }
            }
      
            logger.log(<span class="literal">'getStyle '</span> + property + <span class="literal">' returning '</span> + value, <span class="literal">'info'</span>, <span class="literal">'Dom'</span>);
            <span class="reserved">return</span> value;
         };
         
         <span class="reserved">return</span> util.Dom.batch(el, f, util.Dom, true);
      },
   
      <span class="comment">/**
       * Wrapper for setting style properties of HTMLElements.  Normalizes "opacity" across modern browsers.
       * <span class="attrib">@param</span> {String/HTMLElement/Array} el Accepts a string to use as an ID, an actual DOM reference, or an Array of IDs and/or HTMLElements.
       * <span class="attrib">@param</span> {String} property The style property to be set.
       * <span class="attrib">@param</span> {String} val The value to apply to the given property.
       */</span>
      setStyle: <span class="reserved">function</span>(el, property, val) {
         <span class="reserved">if</span> (!property_cache[property]) {
            cacheConvertedProperties(property);
         }
         
         var camel = property_cache[property][<span class="literal">'camel'</span>];
         
         var f = <span class="reserved">function</span>(el) {
            switch(property) {
               case <span class="literal">'opacity'</span> :
                  <span class="reserved">if</span> (isIE &amp;&amp; typeof el.style.filter == <span class="literal">'string'</span>) { <span class="comment">// in case not appended</span>
                     el.style.filter = <span class="literal">'alpha(opacity='</span> + val * 100 + <span class="literal">')'</span>;
                     
                     <span class="reserved">if</span> (!el.currentStyle || !el.currentStyle.hasLayout) {
                        el.style.zoom = 1; <span class="comment">// when no layout or cant tell</span>
                     }
                  } <span class="reserved">else</span> {
                     el.style.opacity = val;
                     el.style[<span class="literal">'-moz-opacity'</span>] = val;
                     el.style[<span class="literal">'-khtml-opacity'</span>] = val;
                  }

                  break;
               default :
                  el.style[camel] = val;
            }
            
            logger.log(<span class="literal">'setStyle setting '</span> + property + <span class="literal">' to '</span> + val, <span class="literal">'info'</span>, <span class="literal">'Dom'</span>);
            
         };
         
         util.Dom.batch(el, f, util.Dom, true);
      },
      
      <span class="comment">/**
       * Gets the current position of an element based on page coordinates.  Element must be part of the DOM tree to have page coordinates (display:none or elements not appended return false).
       * <span class="attrib">@param</span> {String/HTMLElement/Array} el Accepts a string to use as an ID, an actual DOM reference, or an Array of IDs and/or HTMLElements
       @ return {Array} The XY position of the element(s)
       */</span>
      getXY: <span class="reserved">function</span>(el) {
         var f = <span class="reserved">function</span>(el) {
   
         <span class="comment">// has to be part of document to have pageXY</span>
            <span class="reserved">if</span> (el.parentNode === null || <span class="reserved">this</span>.getStyle(el, <span class="literal">'display'</span>) == <span class="literal">'none'</span>) {
               logger.log(<span class="literal">'getXY failed: element not available'</span>, <span class="literal">'error'</span>, <span class="literal">'Dom'</span>);
               <span class="reserved">return</span> false;
            }
            
            var parentNode = null;
            var pos = [];
            var box;
            
            <span class="reserved">if</span> (el.getBoundingClientRect) { <span class="comment">// IE</span>
               box = el.getBoundingClientRect();
               var doc = document;
               <span class="reserved">if</span> ( !<span class="reserved">this</span>.inDocument(el) ) {<span class="comment">// might be in a frame, need to get its scroll</span>
                  var doc = parent.document;
                  <span class="reserved">while</span> ( doc &amp;&amp; !<span class="reserved">this</span>.isAncestor(doc.documentElement, el) ) {
                     doc = parent.document;
                  }
               }

               var scrollTop = Math.max(doc.documentElement.scrollTop, doc.body.scrollTop);
               var scrollLeft = Math.max(doc.documentElement.scrollLeft, doc.body.scrollLeft);
               
               <span class="reserved">return</span> [box.left + scrollLeft, box.top + scrollTop];
            }
            <span class="reserved">else</span> { <span class="comment">// safari, opera, &amp; gecko</span>
               pos = [el.offsetLeft, el.offsetTop];
               parentNode = el.offsetParent;
               <span class="reserved">if</span> (parentNode != el) {
                  <span class="reserved">while</span> (parentNode) {
                     pos[0] += parentNode.offsetLeft;
                     pos[1] += parentNode.offsetTop;
                     parentNode = parentNode.offsetParent;
                  }
               }
               <span class="reserved">if</span> (isSafari &amp;&amp; <span class="reserved">this</span>.getStyle(el, <span class="literal">'position'</span>) == <span class="literal">'absolute'</span> ) { <span class="comment">// safari doubles in some cases</span>
                  pos[0] -= document.body.offsetLeft;
                  pos[1] -= document.body.offsetTop;
               } 
            }
            
            <span class="reserved">if</span> (el.parentNode) { parentNode = el.parentNode; }
            <span class="reserved">else</span> { parentNode = null; }
      
            <span class="reserved">while</span> (parentNode &amp;&amp; parentNode.tagName.toUpperCase() != <span class="literal">'BODY'</span> &amp;&amp; parentNode.tagName.toUpperCase() != <span class="literal">'HTML'</span>) 
            { <span class="comment">// account for any scrolled ancestors</span>
               pos[0] -= parentNode.scrollLeft;
               pos[1] -= parentNode.scrollTop;
      
               <span class="reserved">if</span> (parentNode.parentNode) { parentNode = parentNode.parentNode; } 
               <span class="reserved">else</span> { parentNode = null; }
            }
      
            logger.log(<span class="literal">'getXY returning '</span> + pos, <span class="literal">'info'</span>, <span class="literal">'Dom'</span>);
            
            <span class="reserved">return</span> pos;
         };
         
         <span class="reserved">return</span> util.Dom.batch(el, f, util.Dom, true);
      },
      
      <span class="comment">/**
       * Gets the current X position of an element based on page coordinates.  The element must be part of the DOM tree to have page coordinates (display:none or elements not appended return false).
       * <span class="attrib">@param</span> {String/HTMLElement/Array} el Accepts a string to use as an ID, an actual DOM reference, or an Array of IDs and/or HTMLElements
       * <span class="attrib">@return</span> {String/Array} The X position of the element(s)
       */</span>
      getX: <span class="reserved">function</span>(el) {
         <span class="reserved">return</span> util.Dom.getXY(el)[0];
      },
      
      <span class="comment">/**
       * Gets the current Y position of an element based on page coordinates.  Element must be part of the DOM tree to have page coordinates (display:none or elements not appended return false).
       * <span class="attrib">@param</span> {String/HTMLElement/Array} el Accepts a string to use as an ID, an actual DOM reference, or an Array of IDs and/or HTMLElements
       * <span class="attrib">@return</span> {String/Array} The Y position of the element(s)
       */</span>
      getY: <span class="reserved">function</span>(el) {
         <span class="reserved">return</span> util.Dom.getXY(el)[1];
      },
      
      <span class="comment">/**
       * Set the position of an html element in page coordinates, regardless of how the element is positioned.
       * The element(s) must be part of the DOM tree to have page coordinates (display:none or elements not appended return false).
       * <span class="attrib">@param</span> {String/HTMLElement/Array} el Accepts a string to use as an ID, an actual DOM reference, or an Array of IDs and/or HTMLElements
       * <span class="attrib">@param</span> {Array} pos Contains X &amp; Y values for new position (coordinates are page-based)
       * <span class="attrib">@param</span> {Boolean} noRetry By default we try and set the position a second time if the first fails
       */</span>
      setXY: <span class="reserved">function</span>(el, pos, noRetry) {
         var f = <span class="reserved">function</span>(el) {
            var style_pos = <span class="reserved">this</span>.getStyle(el, <span class="literal">'position'</span>);
            <span class="reserved">if</span> (style_pos == <span class="literal">'static'</span>) { <span class="comment">// default to relative</span>
               <span class="reserved">this</span>.setStyle(el, <span class="literal">'position'</span>, <span class="literal">'relative'</span>);
               style_pos = <span class="literal">'relative'</span>;
            }
            
            var pageXY = <span class="reserved">this</span>.getXY(el);
            <span class="reserved">if</span> (pageXY === false) { <span class="comment">// has to be part of doc to have pageXY</span>
               logger.log(<span class="literal">'setXY failed: element not available'</span>, <span class="literal">'error'</span>, <span class="literal">'Dom'</span>);
               <span class="reserved">return</span> false; 
            }
            
            var delta = [ <span class="comment">// assuming pixels; if not we will have to retry</span>
               parseInt( <span class="reserved">this</span>.getStyle(el, <span class="literal">'left'</span>), 10 ),
               parseInt( <span class="reserved">this</span>.getStyle(el, <span class="literal">'top'</span>), 10 )
            ];
         
            <span class="reserved">if</span> ( isNaN(delta[0]) ) {<span class="comment">// in case of 'auto'</span>
               delta[0] = (style_pos == <span class="literal">'relative'</span>) ? 0 : el.offsetLeft;
            } 
            <span class="reserved">if</span> ( isNaN(delta[1]) ) { <span class="comment">// in case of 'auto'</span>
               delta[1] = (style_pos == <span class="literal">'relative'</span>) ? 0 : el.offsetTop;
            } 
      
            <span class="reserved">if</span> (pos[0] !== null) { el.style.left = pos[0] - pageXY[0] + delta[0] + <span class="literal">'px'</span>; }
            <span class="reserved">if</span> (pos[1] !== null) { el.style.top = pos[1] - pageXY[1] + delta[1] + <span class="literal">'px'</span>; }
      
            var newXY = <span class="reserved">this</span>.getXY(el);
      
            <span class="comment">// if retry is true, try one more time if we miss </span>
            <span class="reserved">if</span> (!noRetry &amp;&amp; (newXY[0] != pos[0] || newXY[1] != pos[1]) ) {
               <span class="reserved">this</span>.setXY(el, pos, true);
            }
            
            logger.log(<span class="literal">'setXY setting position to '</span> + pos, <span class="literal">'info'</span>, <span class="literal">'Dom'</span>);
         };
         
         util.Dom.batch(el, f, util.Dom, true);
      },
      
      <span class="comment">/**
       * Set the X position of an html element in page coordinates, regardless of how the element is positioned.
       * The element must be part of the DOM tree to have page coordinates (display:none or elements not appended return false).
       * <span class="attrib">@param</span> {String/HTMLElement/Array} el Accepts a string to use as an ID, an actual DOM reference, or an Array of IDs and/or HTMLElements.
       * <span class="attrib">@param</span> {Int} x to use as the X coordinate for the element(s).
       */</span>
      setX: <span class="reserved">function</span>(el, x) {
         util.Dom.setXY(el, [x, null]);
      },
      
      <span class="comment">/**
       * Set the Y position of an html element in page coordinates, regardless of how the element is positioned.
       * The element must be part of the DOM tree to have page coordinates (display:none or elements not appended return false).
       * <span class="attrib">@param</span> {String/HTMLElement/Array} el Accepts a string to use as an ID, an actual DOM reference, or an Array of IDs and/or HTMLElements.
       * <span class="attrib">@param</span> {Int} x to use as the Y coordinate for the element(s).
       */</span>
      setY: <span class="reserved">function</span>(el, y) {
         util.Dom.setXY(el, [null, y]);
      },
      
      <span class="comment">/**
       * Returns the region position of the given element.
       * The element must be part of the DOM tree to have a region (display:none or elements not appended return false).
       * <span class="attrib">@param</span> {String/HTMLElement/Array} el Accepts a string to use as an ID, an actual DOM reference, or an Array of IDs and/or HTMLElements.
       * <span class="attrib">@return</span> {Region/Array} A Region or array of Region instances containing "top, left, bottom, right" member data.
       */</span>
      getRegion: <span class="reserved">function</span>(el) {
         var f = <span class="reserved">function</span>(el) {
            var region = new YAHOO.util.Region.getRegion(el);
            logger.log(<span class="literal">'getRegion returning '</span> + region, <span class="literal">'info'</span>, <span class="literal">'Dom'</span>);
            <span class="reserved">return</span> region;
         };
         
         <span class="reserved">return</span> util.Dom.batch(el, f, util.Dom, true);
      },
      
      <span class="comment">/**
       * Returns the width of the client (viewport).
       * Now using getViewportWidth.  This interface left intact for back compat.
       * <span class="attrib">@return</span> {Int} The width of the viewable area of the page.
       */</span>
      getClientWidth: <span class="reserved">function</span>() {
         <span class="reserved">return</span> util.Dom.getViewportWidth();
      },
      
      <span class="comment">/**
       * Returns the height of the client (viewport).
       * Now using getViewportHeight.  This interface left intact for back compat.
       * <span class="attrib">@return</span> {Int} The height of the viewable area of the page.
       */</span>
      getClientHeight: <span class="reserved">function</span>() {
         <span class="reserved">return</span> util.Dom.getViewportHeight();
      },

      <span class="comment">/**
       * Returns a array of HTMLElements with the given class
       * For optimized performance, include a tag and/or root node if possible
       * <span class="attrib">@param</span> {String} className The class name to match against
       * <span class="attrib">@param</span> {String} tag (optional) The tag name of the elements being collected
       * <span class="attrib">@param</span> {String/HTMLElement} root (optional) The HTMLElement or an ID to use as the starting point 
       * <span class="attrib">@return</span> {Array} An array of elements that have the given class name
       */</span>
      getElementsByClassName: <span class="reserved">function</span>(className, tag, root) {
         var method = <span class="reserved">function</span>(el) { <span class="reserved">return</span> util.Dom.hasClass(el, className) };
         <span class="reserved">return</span> util.Dom.getElementsBy(method, tag, root);
      },

      <span class="comment">/**
       * Determines whether an HTMLElement has the given className
       * <span class="attrib">@param</span> {String/HTMLElement/Array} el The element or collection to test
       * <span class="attrib">@param</span> {String} className the class name to search for
       * <span class="attrib">@return</span> {Boolean/Array} A boolean value or array of boolean values
       */</span>
      hasClass: <span class="reserved">function</span>(el, className) {
         var re = new RegExp(<span class="literal">'(?:^|\\s+)'</span> + className + <span class="literal">'(?:\\s+|$)'</span>);
         
         var f = <span class="reserved">function</span>(el) {
            logger.log(<span class="literal">'hasClass returning '</span> + re.test(el[<span class="literal">'className'</span>]), <span class="literal">'info'</span>, <span class="literal">'Dom'</span>);
            <span class="reserved">return</span> re.test(el[<span class="literal">'className'</span>]);
         };
         
         <span class="reserved">return</span> util.Dom.batch(el, f, util.Dom, true);
      },
   
      <span class="comment">/**
       * Adds a class name to a given element or collection of elements
       * <span class="attrib">@param</span> {String/HTMLElement/Array} el The element or collection to add the class to
       * <span class="attrib">@param</span> {String} className the class name to add to the class attribute
       */</span>
      addClass: <span class="reserved">function</span>(el, className) {
         var f = <span class="reserved">function</span>(el) {
            <span class="reserved">if</span> (<span class="reserved">this</span>.hasClass(el, className)) { <span class="reserved">return</span>; } <span class="comment">// already present</span>
            
            logger.log(<span class="literal">'addClass adding '</span> + className, <span class="literal">'info'</span>, <span class="literal">'Dom'</span>);
            
            el[<span class="literal">'className'</span>] = [el[<span class="literal">'className'</span>], className].join(<span class="literal">' '</span>);
         };
         
         util.Dom.batch(el, f, util.Dom, true);
      },
   
      <span class="comment">/**
       * Removes a class name from a given element or collection of elements
       * <span class="attrib">@param</span> {String/HTMLElement/Array} el The element or collection to remove the class from
       * <span class="attrib">@param</span> {String} className the class name to remove from the class attribute
       */</span>
      removeClass: <span class="reserved">function</span>(el, className) {
         var re = new RegExp(<span class="literal">'(?:^|\\s+)'</span> + className + <span class="literal">'(?:\\s+|$)'</span>, <span class="literal">'g'</span>);

         var f = <span class="reserved">function</span>(el) {
            <span class="reserved">if</span> (!<span class="reserved">this</span>.hasClass(el, className)) { <span class="reserved">return</span>; } <span class="comment">// not present</span>
            
            logger.log(<span class="literal">'removeClass removing '</span> + className, <span class="literal">'info'</span>, <span class="literal">'Dom'</span>);
            
            var c = el[<span class="literal">'className'</span>];
            el[<span class="literal">'className'</span>] = c.replace(re, <span class="literal">' '</span>);
            <span class="reserved">if</span> ( <span class="reserved">this</span>.hasClass(el, className) ) { <span class="comment">// in case of multiple adjacent</span>
               <span class="reserved">this</span>.removeClass(el, className);
            }
            
         };
         
         util.Dom.batch(el, f, util.Dom, true);
      },
      
      <span class="comment">/**
       * Replace a class with another class for a given element or collection of elements.
       * If no oldClassName is present, the newClassName is simply added.
       * <span class="attrib">@param</span> {String/HTMLElement/Array} el The element or collection to remove the class from
       * <span class="attrib">@param</span> {String} oldClassName the class name to be replaced
       * <span class="attrib">@param</span> {String} newClassName the class name that will be replacing the old class name
       */</span>
      replaceClass: <span class="reserved">function</span>(el, oldClassName, newClassName) {
         var re = new RegExp(<span class="literal">'(?:^|\\s+)'</span> + oldClassName + <span class="literal">'(?:\\s+|$)'</span>, <span class="literal">'g'</span>);

         var f = <span class="reserved">function</span>(el) {
            logger.log(<span class="literal">'replaceClass replacing '</span> + oldClassName + <span class="literal">' with '</span> + newClassName, <span class="literal">'info'</span>, <span class="literal">'Dom'</span>);
         
            el[<span class="literal">'className'</span>] = el[<span class="literal">'className'</span>].replace(re, <span class="literal">' '</span> + newClassName + <span class="literal">' '</span>);

            <span class="reserved">if</span> ( <span class="reserved">this</span>.hasClass(el, oldClassName) ) { <span class="comment">// in case of multiple adjacent</span>
               <span class="reserved">this</span>.replaceClass(el, oldClassName, newClassName);
            }
         };
         
         util.Dom.batch(el, f, util.Dom, true);
      },
      
      <span class="comment">/**
       * Generates a unique ID
       * <span class="attrib">@param</span> {String/HTMLElement/Array} el (optional) An optional element array of elements to add an ID to (no ID is added if one is already present)
       * <span class="attrib">@param</span> {String} prefix (optional) an optional prefix to use (defaults to "yui-gen")
       * <span class="attrib">@return</span> {String/Array} The generated ID, or array of generated IDs (or original ID if already present on an element)
       */</span>
      generateId: <span class="reserved">function</span>(el, prefix) {
         prefix = prefix || <span class="literal">'yui-gen'</span>;
         el = el || {};
         
         var f = <span class="reserved">function</span>(el) {
            <span class="reserved">if</span> (el) {
               el = util.Dom.get(el);
            } <span class="reserved">else</span> {
               el = {}; <span class="comment">// just generating ID in this case</span>
            }
            
            <span class="reserved">if</span> (!el.id) {
               el.id = prefix + id_counter++; 
               logger.log(<span class="literal">'generateId generating '</span> + el.id, <span class="literal">'info'</span>, <span class="literal">'Dom'</span>);
            } <span class="comment">// dont override existing</span>
            
            logger.log(<span class="literal">'generateId returning '</span> + el.id, <span class="literal">'info'</span>, <span class="literal">'Dom'</span>);
            
            <span class="reserved">return</span> el.id;
         };
         
         <span class="reserved">return</span> util.Dom.batch(el, f, util.Dom, true);
      },
      
      <span class="comment">/**
       * Determines whether an HTMLElement is an ancestor of another HTML element in the DOM hierarchy
       * <span class="attrib">@param</span> {String/HTMLElement} haystack The possible ancestor
       * <span class="attrib">@param</span> {String/HTMLElement} needle The possible descendent
       * <span class="attrib">@return</span> {Boolean} Whether or not the haystack is an ancestor of needle
       */</span>
      isAncestor: <span class="reserved">function</span>(haystack, needle) {
         haystack = util.Dom.get(haystack);
         <span class="reserved">if</span> (!haystack || !needle) { <span class="reserved">return</span> false; }
         
         var f = <span class="reserved">function</span>(needle) {
            <span class="reserved">if</span> (haystack.contains &amp;&amp; !isSafari) { <span class="comment">// safari "contains" is broken</span>
               logger.log(<span class="literal">'isAncestor returning '</span> + haystack.contains(needle), <span class="literal">'info'</span>, <span class="literal">'Dom'</span>);
               <span class="reserved">return</span> haystack.contains(needle);
            }
            <span class="reserved">else</span> <span class="reserved">if</span> ( haystack.compareDocumentPosition ) {
               logger.log(<span class="literal">'isAncestor returning '</span> + !!(haystack.compareDocumentPosition(needle) &amp; 16), <span class="literal">'info'</span>, <span class="literal">'Dom'</span>);
               <span class="reserved">return</span> !!(haystack.compareDocumentPosition(needle) &amp; 16);
            }
            <span class="reserved">else</span> { <span class="comment">// loop up and test each parent</span>
               var parent = needle.parentNode;
               
               <span class="reserved">while</span> (parent) {
                  <span class="reserved">if</span> (parent == haystack) {
                     logger.log(<span class="literal">'isAncestor returning true'</span>, <span class="literal">'info'</span>, <span class="literal">'Dom'</span>);
                     <span class="reserved">return</span> true;
                  }
                  <span class="reserved">else</span> <span class="reserved">if</span> (parent.tagName.toUpperCase() == <span class="literal">'HTML'</span>) {
                     logger.log(<span class="literal">'isAncestor returning false'</span>, <span class="literal">'info'</span>, <span class="literal">'Dom'</span>);
                     <span class="reserved">return</span> false;
                  }
                  
                  parent = parent.parentNode;
               }
               logger.log(<span class="literal">'isAncestor returning false'</span>, <span class="literal">'info'</span>, <span class="literal">'Dom'</span>);
               <span class="reserved">return</span> false;
            }    
         };
         
         <span class="reserved">return</span> util.Dom.batch(needle, f, util.Dom, true);     
      },
      
      <span class="comment">/**
       * Determines whether an HTMLElement is present in the current document
       * <span class="attrib">@param</span> {String/HTMLElement} el The element to search for
       * <span class="attrib">@return</span> {Boolean} Whether or not the element is present in the current document
       */</span>
      inDocument: <span class="reserved">function</span>(el) {
         var f = <span class="reserved">function</span>(el) {
            <span class="reserved">return</span> <span class="reserved">this</span>.isAncestor(document.documentElement, el);
         };
         
         <span class="reserved">return</span> util.Dom.batch(el, f, util.Dom, true);
      },
      
      <span class="comment">/**
       * Returns a array of HTMLElements that pass the test applied by supplied boolean method
       * For optimized performance, include a tag and/or root node if possible
       * <span class="attrib">@param</span> {Function} method A boolean method to test elements with
       * <span class="attrib">@param</span> {String} tag (optional) The tag name of the elements being collected
       * <span class="attrib">@param</span> {String/HTMLElement} root (optional) The HTMLElement or an ID to use as the starting point 
       */</span>
      getElementsBy: <span class="reserved">function</span>(method, tag, root) {
         tag = tag || <span class="literal">'*'</span>;
         root = util.Dom.get(root) || document;
         
         var nodes = [];
         var elements = root.getElementsByTagName(tag);
         
         <span class="reserved">if</span> ( !elements.length &amp;&amp; (tag == <span class="literal">'*'</span> &amp;&amp; root.all) ) {
            elements = root.all; <span class="comment">// IE &lt; 6</span>
         }
         
         <span class="reserved">for</span> (var i = 0, len = elements.length; i &lt; len; ++i) 
         {
            <span class="reserved">if</span> ( method(elements[i]) ) { nodes[nodes.length] = elements[i]; }
         }

         logger.log(<span class="literal">'getElementsBy returning '</span> + nodes, <span class="literal">'info'</span>, <span class="literal">'Dom'</span>);
         
         <span class="reserved">return</span> nodes;
      },
      
      <span class="comment">/**
       * Returns an array of elements that have had the supplied method applied.
       * The method is called with the element(s) as the first arg, and the optional param as the second ( method(el, o) )
       * <span class="attrib">@param</span> {String/HTMLElement/Array} el (optional) An element or array of elements to apply the method to
       * <span class="attrib">@param</span> {Function} method The method to apply to the element(s)
       * <span class="attrib">@param</span> {Generic} (optional) o An optional arg that is passed to the supplied method
       * <span class="attrib">@param</span> {Boolean} (optional) override Whether or not to override the scope of "method" with "o"
       * <span class="attrib">@return</span> {HTMLElement/Array} The element(s) with the method applied
       */</span>
      batch: <span class="reserved">function</span>(el, method, o, override) {
         var id = el;
         el = util.Dom.get(el);
         
         var scope = (override) ? o : window;
         
         <span class="reserved">if</span> (!el || el.tagName || !el.length) { <span class="comment">// is null or not a collection (tagName for SELECT and others that can be both an element and a collection)</span>
            <span class="reserved">if</span> (!el) {
               logger.log(id + <span class="literal">' not available'</span>, <span class="literal">'error'</span>, <span class="literal">'Dom'</span>);
               <span class="reserved">return</span> false;
            }
            <span class="reserved">return</span> method.call(scope, el, o);
         } 
         
         var collection = [];
         
         <span class="reserved">for</span> (var i = 0, len = el.length; i &lt; len; ++i) {
            <span class="reserved">if</span> (!el[i]) {
               id = id[i];
               logger.log(id + <span class="literal">' not available'</span>, <span class="literal">'error'</span>, <span class="literal">'Dom'</span>);
            }
            collection[collection.length] = method.call(scope, el[i], o);
         }
         
         <span class="reserved">return</span> collection;
      },
      
      <span class="comment">/**
       * Returns the height of the document.
       * <span class="attrib">@return</span> {Int} The height of the actual document (which includes the body and its margin).
       */</span>
      getDocumentHeight: <span class="reserved">function</span>() {
         var scrollHeight=-1,windowHeight=-1,bodyHeight=-1;
         var marginTop = parseInt(util.Dom.getStyle(document.body, <span class="literal">'marginTop'</span>), 10);
         var marginBottom = parseInt(util.Dom.getStyle(document.body, <span class="literal">'marginBottom'</span>), 10);
         
         var mode = document.compatMode;
         
         <span class="reserved">if</span> ( (mode || isIE) &amp;&amp; !isOpera ) { <span class="comment">// (IE, Gecko)</span>
            switch (mode) {
               case <span class="literal">'CSS1Compat'</span>: <span class="comment">// Standards mode</span>
                  scrollHeight = ((window.innerHeight &amp;&amp; window.scrollMaxY) ?  window.innerHeight+window.scrollMaxY : -1);
                  windowHeight = [document.documentElement.clientHeight,self.innerHeight||-1].sort(<span class="reserved">function</span>(a, b){<span class="reserved">return</span>(a-b);})[1];
                  bodyHeight = document.body.offsetHeight + marginTop + marginBottom;
                  break;
               
               default: <span class="comment">// Quirks</span>
                  scrollHeight = document.body.scrollHeight;
                  bodyHeight = document.body.clientHeight;
            }
         } <span class="reserved">else</span> { <span class="comment">// Safari &amp; Opera</span>
            scrollHeight = document.documentElement.scrollHeight;
            windowHeight = self.innerHeight;
            bodyHeight = document.documentElement.clientHeight;
         }
      
         var h = [scrollHeight,windowHeight,bodyHeight].sort(<span class="reserved">function</span>(a, b){<span class="reserved">return</span>(a-b);});
         logger.log(<span class="literal">'getDocumentHeight returning '</span> + h[2], <span class="literal">'info'</span>, <span class="literal">'Dom'</span>);
         <span class="reserved">return</span> h[2];
      },
      
      <span class="comment">/**
       * Returns the width of the document.
       * <span class="attrib">@return</span> {Int} The width of the actual document (which includes the body and its margin).
       */</span>
      getDocumentWidth: <span class="reserved">function</span>() {
         var docWidth=-1,bodyWidth=-1,winWidth=-1;
         var marginRight = parseInt(util.Dom.getStyle(document.body, <span class="literal">'marginRight'</span>), 10);
         var marginLeft = parseInt(util.Dom.getStyle(document.body, <span class="literal">'marginLeft'</span>), 10);
         
         var mode = document.compatMode;
         
         <span class="reserved">if</span> (mode || isIE) { <span class="comment">// (IE, Gecko, Opera)</span>
            switch (mode) {
               case <span class="literal">'CSS1Compat'</span>: <span class="comment">// Standards mode</span>
                  docWidth = document.documentElement.clientWidth;
                  bodyWidth = document.body.offsetWidth + marginLeft + marginRight;
                  winWidth = self.innerWidth || -1;
                  break;
                  
               default: <span class="comment">// Quirks</span>
                  bodyWidth = document.body.clientWidth;
                  winWidth = document.body.scrollWidth;
                  break;
            }
         } <span class="reserved">else</span> { <span class="comment">// Safari</span>
            docWidth = document.documentElement.clientWidth;
            bodyWidth = document.body.offsetWidth + marginLeft + marginRight;
            winWidth = self.innerWidth;
         }
      
         var w = [docWidth,bodyWidth,winWidth].sort(<span class="reserved">function</span>(a, b){<span class="reserved">return</span>(a-b);});
         logger.log(<span class="literal">'getDocumentWidth returning '</span> + w[2], <span class="literal">'info'</span>, <span class="literal">'Dom'</span>);
         <span class="reserved">return</span> w[2];
      },

      <span class="comment">/**
       * Returns the current height of the viewport.
       * <span class="attrib">@return</span> {Int} The height of the viewable area of the page (excludes scrollbars).
       */</span>
      getViewportHeight: <span class="reserved">function</span>() {
         var height = -1;
         var mode = document.compatMode;
      
         <span class="reserved">if</span> ( (mode || isIE) &amp;&amp; !isOpera ) {
            switch (mode) { <span class="comment">// (IE, Gecko)</span>
               case <span class="literal">'CSS1Compat'</span>: <span class="comment">// Standards mode</span>
                  height = document.documentElement.clientHeight;
                  break;
      
               default: <span class="comment">// Quirks</span>
                  height = document.body.clientHeight;
            }
         } <span class="reserved">else</span> { <span class="comment">// Safari, Opera</span>
            height = self.innerHeight;
         }
      
         logger.log(<span class="literal">'getViewportHeight returning '</span> + height, <span class="literal">'info'</span>, <span class="literal">'Dom'</span>);
         <span class="reserved">return</span> height;
      },
      
      <span class="comment">/**
       * Returns the current width of the viewport.
       * <span class="attrib">@return</span> {Int} The width of the viewable area of the page (excludes scrollbars).
       */</span>
      
      getViewportWidth: <span class="reserved">function</span>() {
         var width = -1;
         var mode = document.compatMode;
         
         <span class="reserved">if</span> (mode || isIE) { <span class="comment">// (IE, Gecko, Opera)</span>
            switch (mode) {
            case <span class="literal">'CSS1Compat'</span>: <span class="comment">// Standards mode </span>
               width = document.documentElement.clientWidth;
               break;
               
            default: <span class="comment">// Quirks</span>
               width = document.body.clientWidth;
            }
         } <span class="reserved">else</span> { <span class="comment">// Safari</span>
            width = self.innerWidth;
         }
         logger.log(<span class="literal">'getViewportWidth returning '</span> + width, <span class="literal">'info'</span>, <span class="literal">'Dom'</span>);
         <span class="reserved">return</span> width;
      }
   };
}();

</pre>
			</div>
		
	</div>
</div>


<div id="footer">
	<hr />
	Copyright &copy; 2004 - 2005 Yahoo! Inc. All rights reserved.
	<br />
	Yahoo! Confidential.
	<br /><br />
	Documentation generated by <a href="http://jsdoc.sourceforge.net/">JSDoc</a>
	version 1.9.5.8
</div>


</body>
</html>
